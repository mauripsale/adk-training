import asyncio
from google.adk.sessions import InMemorySessionService
from google.adk.runners import Runner
from basic_agent.agent import root_agent
from google.genai import types
from dotenv import load_dotenv

async def call_agent_async(query:str, runner: Runner, user_id: str, session_id: str):
  """Calls the agent asynchronously with a given query and prints the final response.

  Args:
    query: The user's input query string.
    runner: The runner instance used to run the agent.
    user_id: The ID of the user.
    session_id: The ID of the session.

  Prints:
    The final response from the agent.
  """
  # Create a Content object with the user's query.
  # The role is set to 'user' and the text is included as a Part.
  # This structure is required by the agent's input mechanism.
  # More complex inputs (e.g., with images or other media) would require different Part types.
    content = types.Content(role='user', parts=[types.Part(text=query)])

    final_response_text = "Agent did not produce a final response." # Default

    async for event in runner.run_async(
        user_id=user_id,
        session_id=session_id,
        new_message=content
    ): # Iterate through events generated by the runner during the turn.
      # Events represent different stages or outputs from the agent,
      # such as tool calls, intermediate thoughts, or the final response.

        if event.is_final_response():
          # Key Concept: is_final_response() marks the concluding message for the turn.
          # Once this event is received, we have the final output from the agent
          # for the current turn and can stop processing further events for this turn.
          if event.content and event.content.parts:
             # Assuming text response in the first part
             # This is a common case where the agent responds with a text message.
             # We extract the text from the first part of the content.
             final_response_text = event.content.parts[0].text
          elif event.actions and event.actions.escalate: # Handle potential errors/escalations
             # This block handles cases where the agent escalates or indicates an error.
             # We provide a default message if no specific error message is available.
             final_response_text = f"Agent escalated: {event.error_message or 'No specific message.'}"
          # Add more checks here if needed (e.g., specific error codes)
          # Depending on the agent's design and potential outputs,
          # you might add checks for other event types or content structures here.
          break # Stop processing events once the final response is found

    print(f"<<< Agent Response: {final_response_text}")


async def main():
  """Main function to run the basic agent locally.

  Initializes the session service and runner, then enters a loop
  to take user input and call the agent until the user quits.
  """
  # Load environment variables from a .env file, which might include API keys or other configurations.
    load_dotenv()
    APP_NAME = "basic_agent_app"
    USER_ID = "mauri"
    SESSION_ID = "session_001"
    # Initialize the in-memory session service. This service manages session data for users.
    session_service = InMemorySessionService()

    # Create a new session for the user.
    session = await session_service.create_session(
        app_name=APP_NAME,
        user_id=USER_ID,
        session_id=SESSION_ID
    )

    runner = Runner(
        # Initialize the runner with the root agent and session service.
        agent=root_agent,
        app_name=APP_NAME,
        session_service=session_service,
        )

    while True:
        query = input(">>> User: ")
        if query.lower() in ["exit", "quit"]:
            break
        await call_agent_async(query=query, runner=runner, user_id=USER_ID, session_id=SESSION_ID)

    
    

if __name__ == "__main__":
    asyncio.run(main())